주어진 코드는 차량 정차 상태 및 고온/모션 상태를 확인하고, 특정 조건 충족 시 알림을 보내는 시스템입니다. 그러나 현재 구조에서는 모든 사용자가 공유된 active_sensors 집합과 periodic_check 루프를 사용하기 때문에 사용자별로 독립적으로 동작하지 않습니다. 이를 해결하려면 사용자별 데이터와 주기적 점검 루프를 분리해야 합니다.

다음은 수정된 코드입니다:

import asyncio
import nest_asyncio
from modules.motion import MotionDetector
from modules.temperature_check import TemperatureChecker
import modules.detect_move as detect_move
import modules.telegram_alarm as telegram_alarm

async def main():
    application = telegram_alarm.create_telegram_app()

    user_sessions = {}

    async def periodic_check(user_id, sensor_number):
        print(f"사용자 {user_id}에 대한 주기적 점검을 수행합니다.")

        car_stopped = False

        while True:
            print(f"[{user_id}] 차량 상태를 점검합니다.")
            
            if not car_stopped:
                await asyncio.sleep(20)  # 차량 정차 시뮬레이션 대기 시간
                
                car_stopped = await detect_move.monitor_motion_and_stop()
                print(f"[{user_id}] 차량이 정차 상태로 변경되었습니다. 알림 전송 중...")
                await telegram_alarm.handle_car_stop(application, sensor_number)
                
                print(f"[{user_id}] 3분 대기 중...")
                await asyncio.sleep(20)  # 대기 시간
                
            print(f"[{user_id}] 모션 및 온도 체크 중...")
            
            while True:
                print(f"[{user_id}] 온도를 감지 중...")
                # 고온 감지
                if await temp_checker.check_temperature():
                    while True:
                        print(f"[{user_id}] 모션 센서를 감지 중...")
                        # 모션 센서 감지(총 3번 감지 되면 true)
                        if motion_detector.detect_motion():
                            print(f"[{user_id}] 고온 및 모션 감지 발생. 알림 전송 중...")
                            await telegram_alarm.send_detection_alert(application, sensor_number)
                            break
                        
                        await asyncio.sleep(5)  # 다음 점검까지 

    async def handle_new_user(update: telegram_alarm.Update, context):
        user_id = update.effective_user.id
        print(f"사용자 {user_id} 등록 시도 중...")

        new_sensor_number = await telegram_alarm.start(update, context)
        
        if new_sensor_number:
            if user_id in user_sessions:
                print(f"사용자 {user_id}의 기존 세션이 있습니다. 새 세션을 추가합니다.")
            else:
                print(f"사용자 {user_id}의 새로운 세션을 생성합니다.")
                user_sessions[user_id] = {"sensor_number": new_sensor_number}

            asyncio.create_task(periodic_check(user_id, new_sensor_number))

    application.add_handler(telegram_alarm.CommandHandler("start", handle_new_user))
    await application.run_polling(allowed_updates=telegram_alarm.Update.ALL_TYPES)

if __name__ == '__main__':
    nest_asyncio.apply()
    asyncio.run(main())

주요 변경 사항:

1. 사용자별 데이터 관리:

user_sessions 딕셔너리를 도입하여 사용자별로 sensor_number를 저장했습니다.



2. 사용자별 periodic_check 함수 분리:

periodic_check 함수를 사용자 ID와 센서 번호를 매개변수로 받도록 수정하여 독립적인 작업이 가능하도록 했습니다.



3. handle_new_user 로직 변경:

새 사용자가 등록되면 해당 사용자 ID와 센서 번호를 저장하고, 해당 사용자 전용 periodic_check 루프를 실행합니다.




이제 각 사용자는 독립적으로 periodic_check를 실행하며, 다른 사용자와 간섭 없이 동작합니다.

